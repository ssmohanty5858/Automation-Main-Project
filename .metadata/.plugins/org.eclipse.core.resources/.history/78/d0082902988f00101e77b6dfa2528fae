package util;

import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.List;
import java.util.Map;

public class CanvasPage {

    private final WebDriver driver;
    private final WebDriverWait wait;
    private final JavascriptExecutor js;

    public CanvasPage(WebDriver driver, Duration timeout) {
        this.driver = driver;
        this.wait   = new WebDriverWait(driver, timeout);
        this.js     = (JavascriptExecutor) driver;
    }

    private By canvasLocator() {
        return By.cssSelector("app-drawing-board canvas");
    }

    /** Drag any palette tile (cdk-drag) to the canvas at (fx, fy) where fx/fy are 0..1 fractions. */
    public void dragToCanvas(WebElement source, int fx, int fy) {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(canvasLocator()));

        // Make sure both are in view for reliable pointer math
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", source);
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        // Snapshot canvas to confirm change later
        String before = (String) js.executeScript("return arguments[0].toDataURL('image/png');", canvas);

        // Get viewport rects in CSS pixels (safe wrt zoom/scroll)
        @SuppressWarnings("unchecked")
        Map<String, Number> s = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {x:b.left,y:b.top,w:b.width,h:b.height};", source);
        @SuppressWarnings("unchecked")
        Map<String, Number> c = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {x:b.left,y:b.top,w:b.width,h:b.height};", canvas);

        int startX = (int) Math.round(s.get("x").doubleValue() + s.get("w").doubleValue()/2.0);
        int startY = (int) Math.round(s.get("y").doubleValue() + s.get("h").doubleValue()/2.0);
        int endX   = (int) Math.round(c.get("x").doubleValue() + c.get("w").doubleValue()*fx);
        int endY   = (int) Math.round(c.get("y").doubleValue() + c.get("h").doubleValue()*fy);

        // Actions sequence: nudge to start CDK drag -> move to canvas point -> tiny jiggle -> release
        int nudgeX = 50, nudgeY = 50;                   // exceed CDK drag threshold
        int dx = (endX - startX) - nudgeX;
        int dy = (endY - startY) - nudgeY;
        
        
        new Actions(driver)
            .moveToElement(source)                     // centers by default
            .clickAndHold()
            .pause(Duration.ofMillis(200))
            .moveByOffset(10, 10)
            .pause(Duration.ofMillis(120))
            .moveToElement(canvas, fx ,fy )
            .moveByOffset(3, 3)                        // jiggle so canvas sees a move
            .pause(Duration.ofMillis(80))
            .release()
            .perform();

        // If pixels didn’t change, use PointerEvents fallback (some canvas apps need it)
        String after = (String) js.executeScript("return arguments[0].toDataURL('image/png');", canvas);
        if (before != null && before.equals(after)) {
            pointerEventsFallback(source, endX, endY);
        }
    }

    /** Synthetic pointer events at viewport (x,y) – robust for canvas listeners on document/window. */
    private void pointerEventsFallback(WebElement source, int x, int y) {
        String script =
            "const src=arguments[0], x=arguments[1], y=arguments[2];" +
            "const id=1;" +
            "function pe(t,el,x,y){el.dispatchEvent(new PointerEvent(t,{pointerId:id,pointerType:'mouse',bubbles:true,cancelable:true,buttons:1,clientX:x,clientY:y,isPrimary:true}));}" +
            "function me(t,el,x,y){el.dispatchEvent(new MouseEvent(t,{bubbles:true,cancelable:true,buttons:1,clientX:x,clientY:y}));}" +
            "pe('pointerdown',src,0,0); me('mousedown',src,0,0);" +
            "pe('pointermove',document,x,y); me('mousemove',document,x,y);" +
            "pe('pointermove',document,x+4,y+4); me('mousemove',document,x+4,y+4);" +
            "pe('pointerup',document,x+4,y+4); me('mouseup',document,x+4,y+4);";
        js.executeScript(script, source, x, y);
    }

 
    
    
      
    @SuppressWarnings("unchecked")
    public void clickBlueAreaReliable(double fx, double fy, int insetPx) {
        // 1) elements
        WebElement canvas = wait.until(
            ExpectedConditions.visibilityOfElementLocated(By.cssSelector("app-drawing-board canvas")));
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        // 2) get CSS-3D side overlays (presence, not visibility)
        By sidesBy = By.cssSelector("#css3D p.lineId");
        wait.until(ExpectedConditions.presenceOfElementLocated(sidesBy));
        List<WebElement> sides = driver.findElements(sidesBy);
        if (sides.size() < 4) {
            // fall back: click by fraction of full canvas
            clickCanvasViaPointerSequence(canvas, fx, fy);
            return;
        }

        // 3) classify the four sides by their centers
        record C(double cx, double cy, org.openqa.selenium.WebElement el) {}
        List<C> cs = new java.util.ArrayList<>();
        for (WebElement el : sides) {
            Map<String, Number> r = (Map<String, Number>) js.executeScript(
                "const b=arguments[0].getBoundingClientRect(); return {cx:b.left+b.width/2, cy:b.top+b.height/2, "
              + "l:b.left, t:b.top, r:b.right, btm:b.bottom};", el);
            cs.add(new C(r.get("cx").doubleValue(), r.get("cy").doubleValue(), el));
        }
        C top    = cs.stream().min(java.util.Comparator.comparingDouble(C::cy)).get();
        C bottom = cs.stream().max(java.util.Comparator.comparingDouble(C::cy)).get();
        C left   = cs.stream().min(java.util.Comparator.comparingDouble(C::cx)).get();
        C right  = cs.stream().max(java.util.Comparator.comparingDouble(C::cx)).get();

        // 4) measure inner blue rectangle using the sides' client rects
        Map<String, Number> rt = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left, r:b.right, t:b.top, b:b.bottom};", top.el());
        Map<String, Number> rb = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left, r:b.right, t:b.top, b:b.bottom};", bottom.el());
        Map<String, Number> rl = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left, r:b.right, t:b.top, b:b.bottom};", left.el());
        Map<String, Number> rr = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left, r:b.right, t:b.top, b:b.bottom};", right.el());

        // inner edges (approx): take the inner-most edge of each side box
        double innerLeft   = rl.get("r").doubleValue();
        double innerRight  = rr.get("l").doubleValue();
        double innerTop    = rt.get("b").doubleValue();
        double innerBottom = rb.get("t").doubleValue();

        // 5) choose a point inside that inner rect, with a small inset
        double w = Math.max(2, innerRight - innerLeft);
        double h = Math.max(2, innerBottom - innerTop);
        double x = innerLeft   + w * fx;
        double y = innerTop    + h * fy;

        // apply extra inset if requested
        x = Math.max(innerLeft + insetPx,  Math.min(innerRight  - insetPx, x));
        y = Math.max(innerTop  + insetPx,  Math.min(innerBottom - insetPx, y));

        // 6) fire a full pointer sequence on the element that actually owns that pixel
        js.executeScript(
            "const x=arguments[0], y=arguments[1];" +
            "const el=document.elementFromPoint(x,y) || document.body;" +
            "const ev=(t)=>new PointerEvent(t,{bubbles:true,cancelable:true,clientX:x,clientY:y,pointerType:'mouse',isPrimary:true,buttons:1});" +
            "el.dispatchEvent(ev('pointerover'));"  +
            "el.dispatchEvent(ev('pointerenter'));" +
            "el.dispatchEvent(ev('pointermove'));"  +
            "el.dispatchEvent(ev('pointerdown'));"  +
            "el.dispatchEvent(ev('pointerup'));"    +
            "el.dispatchEvent(new MouseEvent('click',{bubbles:true,cancelable:true,clientX:x,clientY:y,buttons:1}));",
            x, y
        );
    }

    /** Fallback: click at a fraction of the canvas (no overlay info). */
    @SuppressWarnings("unchecked")
    private void clickCanvasViaPointerSequence(WebElement canvas, double fx, double fy) {
        Map<String, Number> r = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left,t:b.top,w:b.width,h:b.height};", canvas);
        double l = r.get("l").doubleValue(), t = r.get("t").doubleValue();
        double w = r.get("w").doubleValue(), h = r.get("h").doubleValue();

        double x = l + Math.max(1, Math.min(w - 2, w * fx));
        double y = t + Math.max(1, Math.min(h - 2, h * fy));

        js.executeScript(
            "const el=document.elementFromPoint(arguments[0],arguments[1])||document.body;" +
            "['pointermove','pointerdown','pointerup','click'].forEach(t=>" +
            "  el.dispatchEvent(new PointerEvent(t,{bubbles:true,cancelable:true,pointerType:'mouse'," +
            "    clientX:arguments[0], clientY:arguments[1], buttons:1})) );", x, y);
    }




}