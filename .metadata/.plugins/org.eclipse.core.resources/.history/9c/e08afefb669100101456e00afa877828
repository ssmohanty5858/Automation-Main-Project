import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.*;

public class ExpressionUtils {

    // Set this elsewhere in your code
    public static int canvasEndX = 0;

    public static int ExpressionSolver(String formula) {
        if (formula == null) throw new IllegalArgumentException("formula is null");

        // Normalize a few common whitespace oddities that can sneak in from CSV/UI
        String sanitized = formula
                .replace('\u00A0', ' ')   // NBSP -> space
                .replace('\u200B', ' ')   // zero-width space -> space
                .trim();

        // LITERAL replacement (not regex)
        String replaced = sanitized.replace("canvasEndX", String.valueOf(canvasEndX));

        // --- DEBUG (optional) ---
        // System.out.println("formula= "+formula+";   replaced= "+replaced+ ";  canvasEndX= "+canvasEndX);

        // Evaluate expression: + - * / ( )
        List<String> tokens = tokenize(replaced);
        List<String> rpn = toRPN(tokens);
        BigDecimal result = evalRPN(rpn);

        return result.setScale(0, RoundingMode.HALF_UP).intValue();
    }

    // ---------- helpers below (unchanged idea) ----------
    private static List<String> tokenize(String s) {
        List<String> out = new ArrayList<>();
        int i = 0, n = s.length();
        while (i < n) {
            char c = s.charAt(i);
            if (Character.isWhitespace(c)) { i++; continue; }
            if ("()+-*/".indexOf(c) >= 0) { out.add(String.valueOf(c)); i++; continue; }
            if (Character.isDigit(c) || c == '.') {
                int j = i + 1;
                while (j < n) {
                    char d = s.charAt(j);
                    if (Character.isDigit(d) || d == '.') j++; else break;
                }
                out.add(s.substring(i, j));
                i = j;
                continue;
            }
            // If there are leftover letters at this point, it means replacement failed
            if (Character.isLetter(c)) {
                int j = i + 1;
                while (j < n && (Character.isLetterOrDigit(s.charAt(j)) || s.charAt(j) == '_')) j++;
                String ident = s.substring(i, j);
                throw new IllegalArgumentException("Unknown identifier after replacement: " + ident + " in: " + s);
            }
            throw new IllegalArgumentException("Unexpected character: '" + c + "' in: " + s);
        }
        return out;
    }

    private static List<String> toRPN(List<String> tokens) {
        List<String> output = new ArrayList<>();
        Deque<String> ops = new ArrayDeque<>();
        Map<String, Integer> prec = Map.of("+", 1, "-", 1, "*", 2, "/", 2);

        for (String t : tokens) {
            if (isNumber(t)) {
                output.add(t);
            } else if (isOperator(t)) {
                while (!ops.isEmpty() && isOperator(ops.peek())
                        && prec.get(ops.peek()) >= prec.get(t)) {
                    output.add(ops.pop());
                }
                ops.push(t);
            } else if ("(".equals(t)) {
                ops.push(t);
            } else if (")".equals(t)) {
                while (!ops.isEmpty() && !"(".equals(ops.peek())) {
                    output.add(ops.pop());
                }
                if (ops.isEmpty() || !"(".equals(ops.pop())) {
                    throw new IllegalArgumentException("Mismatched parentheses");
                }
            } else {
                throw new IllegalArgumentException("Bad token: " + t);
            }
        }
        while (!ops.isEmpty()) {
            String op = ops.pop();
            if ("(".equals(op) || ")".equals(op)) throw new IllegalArgumentException("Mismatched parentheses");
            output.add(op);
        }
        return output;
    }

    private static BigDecimal evalRPN(List<String> rpn) {
        Deque<BigDecimal> st = new ArrayDeque<>();
        for (String t : rpn) {
            if (isNumber(t)) {
                st.push(new BigDecimal(t));
            } else if (isOperator(t)) {
                if (st.size() < 2) throw new IllegalArgumentException("Insufficient operands for " + t);
                BigDecimal b = st.pop();
                BigDecimal a = st.pop();
                switch (t) {
                    case "+" -> st.push(a.add(b));
                    case "-" -> st.push(a.subtract(b));
                    case "*" -> st.push(a.multiply(b));
                    case "/" -> {
                        if (b.compareTo(BigDecimal.ZERO) == 0) throw new ArithmeticException("Division by zero");
                        st.push(a.divide(b, 10, RoundingMode.HALF_UP));
                    }
                }
            } else {
                throw new IllegalArgumentException("Bad RPN token: " + t);
            }
        }
        if (st.size() != 1) throw new IllegalArgumentException("Invalid expression");
        return st.pop();
    }

    private static boolean isOperator(String t) {
        return "+".equals(t) || "-".equals(t) || "*".equals(t) || "/".equals(t);
    }

    private static boolean isNumber(String t) {
        return t.matches("\\d+(?:\\.\\d+)?");
    }
}
