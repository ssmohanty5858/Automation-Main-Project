package util;

import org.openqa.selenium.*;
import org.openqa.selenium.interactions.Actions;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.support.ui.WebDriverWait;

import java.time.Duration;
import java.util.Map;

public class CanvasPage {

    private final WebDriver driver;
    private final WebDriverWait wait;
    private final JavascriptExecutor js;

    public CanvasPage(WebDriver driver, Duration timeout) {
        this.driver = driver;
        this.wait   = new WebDriverWait(driver, timeout);
        this.js     = (JavascriptExecutor) driver;
    }

    private By canvasLocator() {
        return By.cssSelector("app-drawing-board canvas");
    }

    /** Drag any palette tile (cdk-drag) to the canvas at (fx, fy) where fx/fy are 0..1 fractions. */
    public void dragToCanvas(WebElement source, int fx, int fy) {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(canvasLocator()));

        // Make sure both are in view for reliable pointer math
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", source);
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        // Snapshot canvas to confirm change later
        String before = (String) js.executeScript("return arguments[0].toDataURL('image/png');", canvas);

        // Get viewport rects in CSS pixels (safe wrt zoom/scroll)
        @SuppressWarnings("unchecked")
        Map<String, Number> s = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {x:b.left,y:b.top,w:b.width,h:b.height};", source);
        @SuppressWarnings("unchecked")
        Map<String, Number> c = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {x:b.left,y:b.top,w:b.width,h:b.height};", canvas);

        int startX = (int) Math.round(s.get("x").doubleValue() + s.get("w").doubleValue()/2.0);
        int startY = (int) Math.round(s.get("y").doubleValue() + s.get("h").doubleValue()/2.0);
        int endX   = (int) Math.round(c.get("x").doubleValue() + c.get("w").doubleValue()*fx);
        int endY   = (int) Math.round(c.get("y").doubleValue() + c.get("h").doubleValue()*fy);

        // Actions sequence: nudge to start CDK drag -> move to canvas point -> tiny jiggle -> release
        int nudgeX = 50, nudgeY = 50;                   // exceed CDK drag threshold
        int dx = (endX - startX) - nudgeX;
        int dy = (endY - startY) - nudgeY;
        
        
        new Actions(driver)
            .moveToElement(source)                     // centers by default
            .clickAndHold()
            .pause(Duration.ofMillis(200))
            .moveByOffset(10, 10)
            .pause(Duration.ofMillis(120))
            .moveToElement(canvas, fx ,fy )
            .moveByOffset(3, 3)                        // jiggle so canvas sees a move
            .pause(Duration.ofMillis(80))
            .release()
            .perform();

        // If pixels didn’t change, use PointerEvents fallback (some canvas apps need it)
        String after = (String) js.executeScript("return arguments[0].toDataURL('image/png');", canvas);
        if (before != null && before.equals(after)) {
            pointerEventsFallback(source, endX, endY);
        }
    }

    /** Synthetic pointer events at viewport (x,y) – robust for canvas listeners on document/window. */
    private void pointerEventsFallback(WebElement source, int x, int y) {
        String script =
            "const src=arguments[0], x=arguments[1], y=arguments[2];" +
            "const id=1;" +
            "function pe(t,el,x,y){el.dispatchEvent(new PointerEvent(t,{pointerId:id,pointerType:'mouse',bubbles:true,cancelable:true,buttons:1,clientX:x,clientY:y,isPrimary:true}));}" +
            "function me(t,el,x,y){el.dispatchEvent(new MouseEvent(t,{bubbles:true,cancelable:true,buttons:1,clientX:x,clientY:y}));}" +
            "pe('pointerdown',src,0,0); me('mousedown',src,0,0);" +
            "pe('pointermove',document,x,y); me('mousemove',document,x,y);" +
            "pe('pointermove',document,x+4,y+4); me('mousemove',document,x+4,y+4);" +
            "pe('pointerup',document,x+4,y+4); me('mouseup',document,x+4,y+4);";
        js.executeScript(script, source, x, y);
    }

 
    /** Debug click that shows a visual marker at the target (fx,fy) for 'ms' milliseconds. */
    public void clickCanvasAtFraction(double fx, double fy, int ms) {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(
                By.cssSelector("app-drawing-board canvas")));
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        // Compute viewport coords
        Map<String, Number> r = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect();" +
            "return {l:b.left,t:b.top,w:b.width,h:b.height};", canvas);
        double left = r.get("l").doubleValue(),  top = r.get("t").doubleValue();
        double w    = r.get("w").doubleValue(),  h   = r.get("h").doubleValue();

        int x = (int)Math.round(left + Math.max(1, Math.min(w-2, w*fx)));
        int y = (int)Math.round(top  + Math.max(1, Math.min(h-2, h*fy)));

        // Inject a non-interactive marker (so it won't block the click)
        js.executeScript(
            "const x=arguments[0], y=arguments[1], ms=arguments[2];" +
            "const m=document.createElement('div');" +
            "m.style.cssText=" +
            "'position:fixed;left:'+(x-8)+'px;top:'+(y-8)+'px;width:16px;height:16px;" +
            "border:2px solid red;border-radius:50%;background:rgba(255,0,0,.2);" +
            "box-shadow:0 0 0 2px rgba(255,0,0,.35);z-index:2147483647;pointer-events:none;" +
            "transform:scale(1);transition:transform .15s ease-out;';" +
            "document.body.appendChild(m);" +
            "setTimeout(()=>m.style.transform='scale(1.6)', 0);" +
            "setTimeout(()=>{m.remove();}, ms);",
            x, y, ms
        );

        // Perform the actual click at that fraction using Actions (center-based offset)
        Rectangle rr = canvas.getRect();
        int ix = (int)Math.round(Math.max(1, Math.min(rr.getWidth()-2, rr.getWidth()*fx)));
        int iy = (int)Math.round(Math.max(1, Math.min(rr.getHeight()-2, rr.getHeight()*fy)));
        int fromCenterX = -rr.getWidth()/2  + ix;
        int fromCenterY = -rr.getHeight()/2 + iy;

        new Actions(driver)
            .moveToElement(canvas)                 // element center
            .moveByOffset(fromCenterX, fromCenterY)
            .pause(Duration.ofMillis(100))         // brief pause so you can see the marker
            .click()
            .perform();

        System.out.printf("Clicked canvas at fraction (%.2f, %.2f) -> viewport (%d,%d)%n", fx, fy, x, y);
    }

    

    @SuppressWarnings("unchecked")
    public void clickCanvasAtFractionExact(double fx, double fy) {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(
                By.cssSelector("app-drawing-board canvas")));
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        Map<String, Number> r = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect();" +
            "return {l:b.left,t:b.top,w:b.width,h:b.height};", canvas);

        double l = r.get("l").doubleValue(), t = r.get("t").doubleValue();
        double w = r.get("w").doubleValue(), h = r.get("h").doubleValue();

        double cx = l + Math.max(1, Math.min(w - 2, w * fx));
        double cy = t + Math.max(1, Math.min(h - 2, h * fy));

        js.executeScript(
            "const el=arguments[0], x=arguments[1], y=arguments[2];" +
            "['pointermove','pointerdown','pointerup','click'].forEach(t=>" +
            "  el.dispatchEvent(new PointerEvent(t,{bubbles:true,cancelable:true," +
            "    pointerType:'mouse', clientX:x, clientY:y, buttons:1})) );",
            canvas, cx, cy
        );
    }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
 // --- move a virtual pointer and read the canvas' current cursor ---
    @SuppressWarnings("unchecked")
    private String cursorAtFraction(WebElement canvas, double fx, double fy) {
        // ensure visible
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        // compute viewport coordinate
        Map<String, Number> r = (Map<String, Number>) js.executeScript(
            "const b=arguments[0].getBoundingClientRect(); return {l:b.left,t:b.top,w:b.width,h:b.height};",
            canvas);
        double l = r.get("l").doubleValue(), t = r.get("t").doubleValue();
        double w = r.get("w").doubleValue(), h = r.get("h").doubleValue();

        double cx = l + Math.max(1, Math.min(w - 2, w * fx));
        double cy = t + Math.max(1, Math.min(h - 2, h * fy));

        // dispatch a pointermove at that point (so app updates its hover state/cursor)
        js.executeScript(
            "const el=arguments[0], x=arguments[1], y=arguments[2];" +
            "el.dispatchEvent(new PointerEvent('pointermove', {bubbles:true,cancelable:true," +
            "  pointerType:'mouse', clientX:x, clientY:y, buttons:0}));",
            canvas, cx, cy
        );

        // read the effective cursor (app typically sets el.style.cursor)
        return (String) js.executeScript(
            "const el=arguments[0]; return getComputedStyle(el).cursor || el.style.cursor || 'auto';",
            canvas
        );
    }

    // heuristic: does this cursor look like "inside working area"?
    private boolean isInsideCursor(String cursor) {
        if (cursor == null) return false;
        String c = cursor.toLowerCase();
        // typical values inside: 'default', 'move', 'grab', 'grabbing', 'crosshair', 'pointer'
        // typical at edges: 'ew-resize','ns-resize','nesw-resize','nwse-resize'
        return !(c.contains("resize"));
    }

    // scan along a line (horizontal or vertical) to find the first/last "inside" points
    private int scanEdge(WebElement canvas, boolean horizontal, double fixedFrac, double startFrac, double endFrac, int steps) {
        int firstInside = -1, lastInside = -1;
        for (int i = 0; i <= steps; i++) {
            double t = startFrac + (endFrac - startFrac) * (i / (double) steps);
            double fx = horizontal ? t : fixedFrac;
            double fy = horizontal ? fixedFrac : t;
            String cur = cursorAtFraction(canvas, fx, fy);
            if (isInsideCursor(cur)) {
                if (firstInside < 0) firstInside = i;
                lastInside = i;
            }
        }
        // return midpoint index if any inside points found, else -1
        if (firstInside >= 0) return (firstInside + lastInside) / 2;
        return -1;
    }

    /**
     * Measure the inner light-blue rectangle by cursor-probing.
     * Returns {x, y, width, height} in *pixels relative to canvas top-left*.
     * Falls back to 6% insets if cursors don't change.
     */
    public int[] measureInnerBlueRect() {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(
                By.cssSelector("app-drawing-board canvas")));
        js.executeScript("arguments[0].scrollIntoView({block:'center'})", canvas);

        Rectangle rr = canvas.getRect();
        int W = rr.getWidth(), H = rr.getHeight();

        // sample midlines; more steps => finer resolution
        int steps = 40;

        // left/right: scan horizontally at mid Y (0.5)
        int leftIdx  = -1, rightIdx = -1;
        int firstInside = -1;
        for (int i = 0; i <= steps; i++) {
            double fx = i / (double) steps;
            String cur = cursorAtFraction(canvas, fx, 0.5);
            if (isInsideCursor(cur)) { firstInside = i; break; }
        }
        if (firstInside >= 0) {
            // find last inside from the right
            int lastInside = -1;
            for (int i = steps; i >= 0; i--) {
                double fx = i / (double) steps;
                String cur = cursorAtFraction(canvas, fx, 0.5);
                if (isInsideCursor(cur)) { lastInside = i; break; }
            }
            leftIdx = firstInside;
            rightIdx = lastInside;
        }

        // top/bottom: scan vertically at mid X (0.5)
        int topIdx = -1, bottomIdx = -1;
        firstInside = -1;
        for (int i = 0; i <= steps; i++) {
            double fy = i / (double) steps;
            String cur = cursorAtFraction(canvas, 0.5, fy);
            if (isInsideCursor(cur)) { firstInside = i; break; }
        }
        if (firstInside >= 0) {
            int lastInside = -1;
            for (int i = steps; i >= 0; i--) {
                double fy = i / (double) steps;
                String cur = cursorAtFraction(canvas, 0.5, fy);
                if (isInsideCursor(cur)) { lastInside = i; break; }
            }
            topIdx = firstInside;
            bottomIdx = lastInside;
        }

        // convert indices to pixel offsets inside the canvas
        // if probing failed (no cursor change), use a safe fallback inset (~6%)
        int lx = (leftIdx   >= 0) ? (int)Math.round((leftIdx   / (double)steps) * W) : (int)Math.round(0.06 * W);
        int rx = (rightIdx  >= 0) ? (int)Math.round((rightIdx  / (double)steps) * W) : (int)Math.round(0.94 * W);
        int ty = (topIdx    >= 0) ? (int)Math.round((topIdx    / (double)steps) * H) : (int)Math.round(0.06 * H);
        int by = (bottomIdx >= 0) ? (int)Math.round((bottomIdx / (double)steps) * H) : (int)Math.round(0.94 * H);

        // clamp and ensure non-negative width/height
        lx = Math.max(1, Math.min(W-2, lx));
        rx = Math.max(lx+2, Math.min(W-2, rx));
        ty = Math.max(1, Math.min(H-2, ty));
        by = Math.max(ty+2, Math.min(H-2, by));

        int x = lx, y = ty, w = rx - lx, h = by - ty;
        return new int[]{x, y, w, h};
    }

    /** Convenience: click the center of the measured blue rect. */
    public void clickBlueCenter() {
        WebElement canvas = wait.until(ExpectedConditions.visibilityOfElementLocated(
                By.cssSelector("app-drawing-board canvas")));
        int[] r = measureInnerBlueRect(); // {x,y,w,h}
        int cx = r[0] + r[2]/2;
        int cy = r[1] + r[3]/2;

        new Actions(driver)
            .moveToElement(canvas, 0, 0)
            .moveByOffset(cx, cy)
            .click()
            .perform();
    }
    
    

    
    
}
